/** @generated by @calimero/abi-codegen â€” DO NOT EDIT. */

import {
  CalimeroApp,
  Context,
} from '@calimero-network/calimero-client';

import * as Types from "./types.js";

export * from "./types.js";

export class AbiConformanceClient {
  private app: CalimeroApp;
  private context: Context;

  constructor(app: CalimeroApp, context: Context) {
    this.app = app;
    this.context = context;
  }

  /**
   * init
   */
  public async init(): Promise<Types.AbiState> {
    const response = await this.app.execute(this.context, 'init', {});
    if (response.success) {
      return response.result as Types.AbiState;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * noop
   */
  public async noop(): Promise<void> {
    const response = await this.app.execute(this.context, 'noop', {});
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_bool
   */
  public async echoBool(params: { b: boolean }): Promise<boolean> {
    const response = await this.app.execute(this.context, 'echo_bool', params);
    if (response.success) {
      return response.result as boolean;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_i32
   */
  public async echoI32(params: { x: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_i32', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_i64
   */
  public async echoI64(params: { x: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_i64', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_u32
   */
  public async echoU32(params: { x: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_u32', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_u64
   */
  public async echoU64(params: { x: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_u64', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_f32
   */
  public async echoF32(params: { x: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_f32', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_f64
   */
  public async echoF64(params: { x: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_f64', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_string
   */
  public async echoString(params: { s: string }): Promise<string> {
    const response = await this.app.execute(this.context, 'echo_string', params);
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_bytes
   */
  public async echoBytes(params: { b: Uint8Array }): Promise<Uint8Array> {
    const response = await this.app.execute(this.context, 'echo_bytes', { b: Array.from(params.b) });
    if (response.success) {
      return response.result as Uint8Array;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * opt_u32
   */
  public async optU32(params: { x: number | null }): Promise<number | null> {
    const response = await this.app.execute(this.context, 'opt_u32', params);
    if (response.success) {
      return response.result as number | null;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * opt_string
   */
  public async optString(params: { x: string | null }): Promise<string | null> {
    const response = await this.app.execute(this.context, 'opt_string', params);
    if (response.success) {
      return response.result as string | null;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * opt_record
   */
  public async optRecord(params: { p: Types.Person | null }): Promise<Types.Person | null> {
    const response = await this.app.execute(this.context, 'opt_record', params);
    if (response.success) {
      return response.result as Types.Person | null;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * opt_id
   */
  public async optId(params: { x: Types.UserId32 | null }): Promise<Types.UserId32 | null> {
    const response = await this.app.execute(this.context, 'opt_id', params);
    if (response.success) {
      return response.result as Types.UserId32 | null;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * list_u32
   */
  public async listU32(params: { xs: number[] }): Promise<number[]> {
    const response = await this.app.execute(this.context, 'list_u32', params);
    if (response.success) {
      return response.result as number[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * list_strings
   */
  public async listStrings(params: { xs: string[] }): Promise<string[]> {
    const response = await this.app.execute(this.context, 'list_strings', params);
    if (response.success) {
      return response.result as string[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * list_records
   */
  public async listRecords(params: { ps: Types.Person[] }): Promise<Types.Person[]> {
    const response = await this.app.execute(this.context, 'list_records', params);
    if (response.success) {
      return response.result as Types.Person[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * list_ids
   */
  public async listIds(params: { xs: Types.UserId32[] }): Promise<Types.UserId32[]> {
    const response = await this.app.execute(this.context, 'list_ids', params);
    if (response.success) {
      return response.result as Types.UserId32[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * map_u32
   */
  public async mapU32(params: { m: Record<string, number> }): Promise<Record<string, number>> {
    const response = await this.app.execute(this.context, 'map_u32', params);
    if (response.success) {
      return response.result as Record<string, number>;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * map_list_u32
   */
  public async mapListU32(params: { m: Record<string, number[]> }): Promise<Record<string, number[]>> {
    const response = await this.app.execute(this.context, 'map_list_u32', params);
    if (response.success) {
      return response.result as Record<string, number[]>;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * map_record
   */
  public async mapRecord(params: { m: Record<string, Types.Person> }): Promise<Record<string, Types.Person>> {
    const response = await this.app.execute(this.context, 'map_record', params);
    if (response.success) {
      return response.result as Record<string, Types.Person>;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * make_person
   */
  public async makePerson(params: { p: Types.Person }): Promise<Types.Person> {
    const response = await this.app.execute(this.context, 'make_person', params);
    if (response.success) {
      return response.result as Types.Person;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * profile_roundtrip
   */
  public async profileRoundtrip(params: { p: Types.Profile }): Promise<Types.Profile> {
    const response = await this.app.execute(this.context, 'profile_roundtrip', params);
    if (response.success) {
      return response.result as Types.Profile;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * act
   */
  public async act(params: { a: Types.ActionPayload }): Promise<number> {
    // Convert Action variant to WASM format
    const convertedParams = { ...params };
    if (convertedParams.a && typeof convertedParams.a === 'object' && 'name' in convertedParams.a) {
      if ('payload' in convertedParams.a) {
        convertedParams.a = { [convertedParams.a.name]: convertedParams.a.payload };
      } else {
        convertedParams.a = convertedParams.a.name;
      }
    }
    const response = await this.app.execute(this.context, 'act', convertedParams);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * roundtrip_id
   */
  public async roundtripId(params: { x: Types.UserId32 }): Promise<Types.UserId32> {
    const response = await this.app.execute(this.context, 'roundtrip_id', { x: Array.from(params.x) });
    if (response.success) {
      return response.result as Types.UserId32;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * roundtrip_hash
   */
  public async roundtripHash(params: { h: Types.Hash64 }): Promise<Types.Hash64> {
    const response = await this.app.execute(this.context, 'roundtrip_hash', { h: Array.from(params.h)});
    if (response.success) {
      return response.result as Types.Hash64;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * may_fail
   */
  public async mayFail(params: { flag: boolean }): Promise<number> {
    const response = await this.app.execute(this.context, 'may_fail', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * find_person
   */
  public async findPerson(params: { name: string }): Promise<Types.Person> {
    const response = await this.app.execute(this.context, 'find_person', params);
    if (response.success) {
      return response.result as Types.Person;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

}