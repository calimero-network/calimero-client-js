// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Codegen > client.ts generation > should generate client.ts with correct structure 1`] = `
"/** @generated by @calimero/abi-codegen â€” DO NOT EDIT. */

import {
  CalimeroApp,
  Context,
} from '@calimero-network/calimero-client';

import * as Types from "./types.js";

export * from "./types.js";

export class TestClient {
  private app: CalimeroApp;
  private context: Context;

  constructor(app: CalimeroApp, context: Context) {
    this.app = app;
    this.context = context;
  }

  /**
   * Utility function to convert hex string to Uint8Array
   */
  private hexToBytes(hex: string): Uint8Array {
    return new Uint8Array(hex.match(/.{1,2}/g)?.map(byte => parseInt(byte, 16)) || []);
  }

  /**
   * Utility function to convert Uint8Array to hex string
   */
  private bytesToHex(bytes: Uint8Array): string {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  /**
   * Utility function to deserialize bytes from contract responses
   */
  private deserializeBytes(result: any): Uint8Array {
    if (Array.isArray(result)) {
      return new Uint8Array(result);
    }
    // Handle case where result might be a hex string
    if (typeof result === 'string') {
      return this.hexToBytes(result);
    }
    throw new Error(\`Unexpected bytes result format: \${typeof result}\`);
  }

  /**
   * Utility function to convert complex types with hex bytes fields
   */
  private convertComplexType(obj: any, typeRef: any): any {
    if (!obj) return obj;
    const result = { ...obj };
    if (typeRef.$ref === "Person") {
      if (typeof result.id === "string") {
        result.id = Array.from(this.hexToBytes(result.id));
      }
    } else if (typeRef.$ref === "Profile") {
      if (typeof result.avatar === "string") {
        result.avatar = Array.from(this.hexToBytes(result.avatar));
      }
    } else if (typeRef.$ref === "UpdatePayload") {
      if (typeof result.id === "string") {
        result.id = Array.from(this.hexToBytes(result.id));
      }
    }
    return result;
  }

  /**
   * Utility function to convert enum variants to contract format
   */
  private convertVariant(variant: any, typeRef: any): any {
    if (!variant) return variant;
    
    if (typeRef.$ref === "Action") {
      // Convert Action variant to WASM format
      if (typeof variant === "object" && "name" in variant) {
        if ("payload" in variant) {
          // Convert complex payload types if needed
          let convertedPayload = variant.payload;
          if (variant.name === "Update" && typeof variant.payload === "object") {
            convertedPayload = this.convertComplexType(variant.payload, { $ref: "UpdatePayload" });
          }
          return { [variant.name]: convertedPayload };
        } else {
          return variant.name;
        }
      } else if (typeof variant === "string") {
        return variant;
      }
    }
    
    return variant;
  }

  /**
   * init
   */
  public async init(): Promise<Types.AbiState> {
    const response = await this.app.execute(this.context, 'init', {});
    if (response.success) {
      return response.result as Types.AbiState;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * noop
   */
  public async noop(): Promise<void> {
    const response = await this.app.execute(this.context, 'noop', {});
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_bool
   */
  public async echoBool(params: { b: boolean }): Promise<boolean> {
    const response = await this.app.execute(this.context, 'echo_bool', params);
    if (response.success) {
      return response.result as boolean;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_i32
   */
  public async echoI32(params: { v: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_i32', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_i64
   */
  public async echoI64(params: { v: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_i64', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_u32
   */
  public async echoU32(params: { v: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_u32', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_u64
   */
  public async echoU64(params: { v: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_u64', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_f32
   */
  public async echoF32(params: { v: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_f32', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_f64
   */
  public async echoF64(params: { v: number }): Promise<number> {
    const response = await this.app.execute(this.context, 'echo_f64', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_string
   */
  public async echoString(params: { s: string }): Promise<string> {
    const response = await this.app.execute(this.context, 'echo_string', params);
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * echo_bytes
   */
  public async echoBytes(params: { b: string }): Promise<string> {
    const convertedParams = {
      b: Array.from(this.hexToBytes(params.b)),
    };
    const response = await this.app.execute(this.context, 'echo_bytes', convertedParams);
    if (response.success) {
      const resultBytes = this.deserializeBytes(response.result);
      return this.bytesToHex(resultBytes) as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * opt_u32
   */
  public async optU32(params: { x: number | null }): Promise<number | null> {
    const response = await this.app.execute(this.context, 'opt_u32', params);
    if (response.success) {
      return response.result as number | null;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * opt_string
   */
  public async optString(params: { x: string | null }): Promise<string | null> {
    const response = await this.app.execute(this.context, 'opt_string', params);
    if (response.success) {
      return response.result as string | null;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * opt_record
   */
  public async optRecord(params: { p: Types.Person | null }): Promise<Types.Person | null> {
    const convertedParams = {
      p: params.p ? this.convertComplexType(params.p, {"$ref":"Person"}) : null,
    };
    const response = await this.app.execute(this.context, 'opt_record', convertedParams);
    if (response.success) {
      return response.result as Types.Person | null;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * opt_id
   */
  public async optId(params: { x: string | null }): Promise<string | null> {
    const convertedParams = {
      x: params.x ? Array.from(this.hexToBytes(params.x)) : null,
    };
    const response = await this.app.execute(this.context, 'opt_id', convertedParams);
    if (response.success) {
      if (response.result === null) {
        return null as string | null;
      }
      const resultBytes = this.deserializeBytes(response.result);
      return this.bytesToHex(resultBytes) as string | null;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * list_u32
   */
  public async listU32(params: { xs: number[] }): Promise<number[]> {
    const response = await this.app.execute(this.context, 'list_u32', params);
    if (response.success) {
      return response.result as number[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * list_strings
   */
  public async listStrings(params: { xs: string[] }): Promise<string[]> {
    const response = await this.app.execute(this.context, 'list_strings', params);
    if (response.success) {
      return response.result as string[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * list_records
   */
  public async listRecords(params: { ps: string }): Promise<string> {
    const response = await this.app.execute(this.context, 'list_records', params);
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * list_ids
   */
  public async listIds(params: { xs: string }): Promise<string> {
    const response = await this.app.execute(this.context, 'list_ids', params);
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * map_u32
   */
  public async mapU32(params: { m: Record<string, number> }): Promise<Record<string, number>> {
    const response = await this.app.execute(this.context, 'map_u32', params);
    if (response.success) {
      return response.result as Record<string, number>;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * map_list_u32
   */
  public async mapListU32(params: { m: Record<string, number[]> }): Promise<Record<string, number[]>> {
    const response = await this.app.execute(this.context, 'map_list_u32', params);
    if (response.success) {
      return response.result as Record<string, number[]>;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * map_record
   */
  public async mapRecord(params: { m: string }): Promise<string> {
    const response = await this.app.execute(this.context, 'map_record', params);
    if (response.success) {
      return response.result as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * make_person
   */
  public async makePerson(params: { p: Types.Person }): Promise<Types.Person> {
    const convertedParams = {
      p: params.p ? this.convertComplexType(params.p, {"$ref":"Person"}) : null,
    };
    const response = await this.app.execute(this.context, 'make_person', convertedParams);
    if (response.success) {
      return response.result as Types.Person;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * profile_roundtrip
   */
  public async profileRoundtrip(params: { p: Types.Profile }): Promise<Types.Profile> {
    const convertedParams = {
      p: params.p ? this.convertComplexType(params.p, {"$ref":"Profile"}) : null,
    };
    const response = await this.app.execute(this.context, 'profile_roundtrip', convertedParams);
    if (response.success) {
      return response.result as Types.Profile;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * act
   */
  public async act(params: { a: Types.ActionPayload }): Promise<number> {
    const convertedParams = {
      a: params.a ? this.convertVariant(params.a, {"$ref":"Action"}) : null,
    };
    const response = await this.app.execute(this.context, 'act', convertedParams);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * roundtrip_id
   */
  public async roundtripId(params: { x: string }): Promise<string> {
    const convertedParams = {
      x: Array.from(this.hexToBytes(params.x)),
    };
    const response = await this.app.execute(this.context, 'roundtrip_id', convertedParams);
    if (response.success) {
      const resultBytes = this.deserializeBytes(response.result);
      return this.bytesToHex(resultBytes) as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * roundtrip_hash
   */
  public async roundtripHash(params: { h: string }): Promise<string> {
    const convertedParams = {
      h: Array.from(this.hexToBytes(params.h)),
    };
    const response = await this.app.execute(this.context, 'roundtrip_hash', convertedParams);
    if (response.success) {
      const resultBytes = this.deserializeBytes(response.result);
      return this.bytesToHex(resultBytes) as string;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * may_fail
   *
   * @throws {Error} May throw the following errors:
   * - BAD_INPUT
   * - NOT_FOUND: string
   */
  public async mayFail(params: { flag: boolean }): Promise<number> {
    const response = await this.app.execute(this.context, 'may_fail', params);
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * find_person
   *
   * @throws {Error} May throw the following errors:
   * - BAD_INPUT
   * - NOT_FOUND: string
   */
  public async findPerson(params: { name: string }): Promise<Types.Person> {
    const response = await this.app.execute(this.context, 'find_person', params);
    if (response.success) {
      return response.result as Types.Person;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

}"
`;

exports[`Codegen > types.ts generation > should generate types.ts with correct structure 1`] = `
"/** @generated by @calimero/abi-codegen â€” DO NOT EDIT. */

export interface AbiState {
  counters: Record<string, number>;
  users: UserId32[];
}

export type ActionPayload =
  | { name: 'Ping' }
  | { name: 'SetName'; payload: string }
  | { name: 'Update'; payload: UpdatePayload }

export const Action = {
  Ping: (): ActionPayload => ({ name: 'Ping' }),
  SetName: (setname: string): ActionPayload => ({ name: 'SetName', payload: setname }),
  Update: (update: UpdatePayload): ActionPayload => ({ name: 'Update', payload: update }),
} as const;

export type ConformanceErrorPayload =
  | { name: 'BadInput' }
  | { name: 'NotFound'; payload: string }

export const ConformanceError = {
  BadInput: (): ConformanceErrorPayload => ({ name: 'BadInput' }),
  NotFound: (notfound: string): ConformanceErrorPayload => ({ name: 'NotFound', payload: notfound }),
} as const;

/** Fixed-length bytes (size: 64). Represented as string at runtime. */
export type Hash64 = string;

export interface Person {
  id: UserId32;
  name: string;
  age: number;
}

export interface Profile {
  bio: string | null;
  avatar: string | null;
  nicknames: string[];
}

/** Fixed-length bytes (size: 32). Represented as string at runtime. */
export type UserId32 = string;

export interface UpdatePayload {
  id: UserId32;
  data: string;
}

export type may_failErrorCode = "BAD_INPUT" | "NOT_FOUND";
export type may_failError = { code: may_failErrorCode } & (
  | { code: "BAD_INPUT" }
  | { code: "NOT_FOUND"; payload: string }
);

export type find_personErrorCode = "BAD_INPUT" | "NOT_FOUND";
export type find_personError = { code: find_personErrorCode } & (
  | { code: "BAD_INPUT" }
  | { code: "NOT_FOUND"; payload: string }
);


export type NamedPayload = string;

export type DataPayload = Uint8Array;

export type PersonUpdatedPayload = string;

export type ActionTakenPayload = string;

export type AbiEvent =
  | { name: "Ping" }
  | { name: "Named"; payload: string }
  | { name: "Data"; payload: Uint8Array }
  | { name: "PersonUpdated"; payload: string }
  | { name: "ActionTaken"; payload: string }
;
"
`;
