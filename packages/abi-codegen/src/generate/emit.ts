/**
 * Helper functions for emitting generated code
 */

/**
 * Generate a file banner for generated files
 */
export function generateFileBanner(): string {
  return '/** @generated by @calimero/abi-codegen â€” DO NOT EDIT. */\n';
}

/**
 * Format a TypeScript identifier to be safe for use in code
 * @param name - The name to format
 * @returns A safe TypeScript identifier
 */
export function formatIdentifier(name: string): string {
  // Handle reserved keywords and special characters
  const reservedKeywords = new Set([
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'enum',
    'export',
    'extends',
    'false',
    'finally',
    'for',
    'function',
    'if',
    'import',
    'in',
    'instanceof',
    'let',
    'new',
    'null',
    'return',
    'super',
    'switch',
    'this',
    'throw',
    'true',
    'try',
    'typeof',
    'var',
    'void',
    'while',
    'with',
    'yield',
    'abstract',
    'boolean',
    'byte',
    'char',
    'double',
    'final',
    'float',
    'goto',
    'implements',
    'int',
    'interface',
    'long',
    'native',
    'package',
    'private',
    'protected',
    'public',
    'short',
    'static',
    'synchronized',
    'throws',
    'transient',
    'volatile',
  ]);

  if (reservedKeywords.has(name)) {
    return `${name}_`;
  }

  // Replace invalid characters with underscores
  return name.replace(/[^a-zA-Z0-9_$]/g, '_');
}

/**
 * Convert a string to PascalCase for type names
 * @param str - The string to convert
 * @returns PascalCase string
 */
export function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

/**
 * Convert a string to camelCase for method names
 * @param str - The string to convert
 * @returns camelCase string
 */
export function toCamelCase(str: string): string {
  const pascal = toPascalCase(str);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

/**
 * Derive a client class name from a file path
 * @param p - The file path to derive the name from
 * @returns The derived client class name
 */
export function deriveClientNameFromPath(p: string): string {
  const base = (p.split(/[\\/]/).pop() || "").replace(/\.[^.]+$/, ""); // strip extension
  const parts = base.split(/[^A-Za-z0-9]+/).filter(Boolean);
  const word = (s: string) =>
    s.length <= 2 ? s.toUpperCase() : (s[0].toUpperCase() + s.slice(1).toLowerCase());
  const pascal = parts.map(word).join("");
  return pascal + "Client";
}
