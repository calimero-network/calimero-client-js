#!/usr/bin/env node

import fs from 'fs';
import path from 'path';

const getArgs = () => {
  const args: { [key: string]: string } = {};
  process.argv.slice(2).forEach((arg) => {
    if (arg.startsWith('--')) {
      const [key, value] = arg.split('=');
      args[key.substring(2)] = value;
    }
  });
  return args;
};

const args = getArgs();
const abiPath = args.abi || 'abi.json';
const outputPath = args.out || 'src/generated-client.ts';

const abiFilePath = path.resolve(process.cwd(), abiPath);
const outputFilePath = path.resolve(process.cwd(), outputPath);

if (!fs.existsSync(abiFilePath)) {
  console.error(`Error: ABI file not found at ${abiFilePath}`);
  process.exit(1);
}

const abi = JSON.parse(fs.readFileSync(abiFilePath, 'utf-8'));

const mapAbiTypeToTs = (abiType: { type: string }): string => {
  let typeStr = abiType.type.trim();

  // Extract content from Result<T> if present, e.g., "app :: Result <T>" -> "T"
  const resultMatch = typeStr.match(/Result < (.*) >/);
  if (resultMatch) {
    typeStr = resultMatch[1].trim();
  }

  // Handle Option<T> -> T | null
  const optionMatch = typeStr.match(/Option < (.*) >/);
  if (optionMatch) {
    const innerType = mapAbiTypeToTs({ type: optionMatch[1] });
    return `${innerType} | null`;
  }

  // Handle BTreeMap<K, V> -> Map<K, V>
  const mapMatch = typeStr.match(/BTreeMap < (.*), (.*) >/);
  if (mapMatch) {
    const keyType = mapAbiTypeToTs({ type: mapMatch[1] });
    const valueType = mapAbiTypeToTs({ type: mapMatch[2] });
    return `Map<${keyType}, ${valueType}>`;
  }

  // Handle unit type "()" -> void
  if (typeStr === '()') {
    return 'void';
  }

  const lowerTypeStr = typeStr.toLowerCase();

  if (lowerTypeStr.includes('string') || lowerTypeStr.includes('str')) {
    return 'string';
  }

  if (
    ['usize', 'u64', 'u32', 'u16', 'u8'].some((numType) =>
      lowerTypeStr.includes(numType),
    )
  ) {
    return 'number';
  }

  return 'any';
};

const generateMethod = (method: any): string => {
  const argsName = 'params';
  const hasArgs = method.args.length > 0;

  const argsType = hasArgs
    ? `{ ${method.args.map((arg: any) => `${arg.name}: ${mapAbiTypeToTs(arg.type)}`).join('; ')} }`
    : '';

  const params = hasArgs ? `${argsName}: ${argsType}` : '';
  const returnType = mapAbiTypeToTs(method.result);

  const returnStatement =
    returnType === 'void'
      ? 'return;'
      : `return response.result as ${returnType};`;

  return `
  public async ${method.name}(${params}): Promise<${returnType}> {
    const response = await this.app.execute(this.context, '${method.name}', ${hasArgs ? argsName : '{}'});
    if (response.success) {
      ${returnStatement}
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }
`;
};

const classString = `/* eslint-disable */
// Auto-generated by calimero-sdk-codegen. Do not edit.

import { CalimeroApp, Context } from '@calimero-network/calimero-client';

export class ContractClient {
  private app: CalimeroApp;
  private context: Context;

  constructor(app: CalimeroApp, context: Context) {
    this.app = app;
    this.context = context;
  }
${abi.methods.map(generateMethod).join('')}
}
`;

const outputDir = path.dirname(outputFilePath);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

fs.writeFileSync(outputFilePath, classString, 'utf-8');

console.log(`âœ… Contract client generated successfully at ${outputFilePath}`);
